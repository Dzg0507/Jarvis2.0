/**
 * URL Extraction and Sanitization Utilities
 * 
 * This module provides intelligent data extraction from web search results,
 * converting raw HTML/CSS/JS content into clean, structured JSON data.
 */

// Structured web search content schema
export interface WebSearchContent {
  youtube_channel_url: string | null;
  twitch_channel_url: string | null;
  additional_links: string[];
  extraction_metadata: {
    sources_found: number;
    extraction_successful: boolean;
  };
}

// URL validation patterns for different platforms
const URL_PATTERNS = {
  youtube_channel: [
    /https?:\/\/(?:www\.)?youtube\.com\/@([a-zA-Z0-9_-]+)/,
    /https?:\/\/(?:www\.)?youtube\.com\/c\/([a-zA-Z0-9_-]+)/,
    /https?:\/\/(?:www\.)?youtube\.com\/channel\/([a-zA-Z0-9_-]+)/,
    /https?:\/\/(?:www\.)?youtube\.com\/user\/([a-zA-Z0-9_-]+)/
  ],
  twitch_channel: [
    /https?:\/\/(?:www\.)?twitch\.tv\/([a-zA-Z0-9_-]+)/
  ],
  youtube_search: [
    /https?:\/\/(?:www\.)?youtube\.com\/results\?search_query=([^&]+)/
  ],
  reddit_search: [
    /https?:\/\/(?:www\.)?reddit\.com\/r\/[^\/]+\/search\/\?q=([^&]+)/
  ]
};

// Legitimate video platform domains
const ALLOWED_DOMAINS = [
  'youtube.com',
  'youtu.be',
  'twitch.tv',
  'vimeo.com',
  'reddit.com',
  'twitter.com',
  'x.com'
];

/**
 * Validates and sanitizes a URL
 * @param url - The URL to validate
 * @returns The sanitized URL or null if invalid
 */
export function validateAndSanitizeUrl(url: string): string | null {
  try {
    // Parse the URL to validate structure
    const parsedUrl = new URL(url);
    
    // Check if domain is allowed
    const domain = parsedUrl.hostname.replace(/^www\./, '');
    if (!ALLOWED_DOMAINS.includes(domain)) {
      return null;
    }
    
    // Remove suspicious parameters
    const suspiciousParams = ['redirect', 'r', 'ref', 'utm_', 'fbclid', 'gclid'];
    const searchParams = new URLSearchParams(parsedUrl.search);
    
    for (const [key] of searchParams) {
      if (suspiciousParams.some(param => key.startsWith(param))) {
        searchParams.delete(key);
      }
    }
    
    // Reconstruct clean URL
    parsedUrl.search = searchParams.toString();
    return parsedUrl.toString();
    
  } catch (error) {
    // Invalid URL format
    return null;
  }
}

/**
 * Extracts channel URLs from AI-generated URLs
 * @param urls - Array of URLs from AI generation
 * @returns Object with extracted channel URLs
 */
export function extractChannelUrls(urls: string[]): { youtube: string | null; twitch: string | null } {
  let youtubeChannel: string | null = null;
  let twitchChannel: string | null = null;
  
  for (const url of urls) {
    const cleanUrl = validateAndSanitizeUrl(url);
    if (!cleanUrl) continue;
    
    // Check for YouTube channel patterns
    if (!youtubeChannel) {
      for (const pattern of URL_PATTERNS.youtube_channel) {
        if (pattern.test(cleanUrl)) {
          youtubeChannel = cleanUrl;
          break;
        }
      }
    }
    
    // Check for Twitch channel patterns
    if (!twitchChannel) {
      for (const pattern of URL_PATTERNS.twitch_channel) {
        if (pattern.test(cleanUrl)) {
          twitchChannel = cleanUrl;
          break;
        }
      }
    }
    
    // Stop if we found both
    if (youtubeChannel && twitchChannel) break;
  }
  
  return { youtube: youtubeChannel, twitch: twitchChannel };
}

/**
 * Extracts additional relevant links from URLs
 * @param urls - Array of URLs from AI generation
 * @param excludeChannels - Channel URLs to exclude from additional links
 * @returns Array of additional relevant links
 */
export function extractAdditionalLinks(urls: string[], excludeChannels: string[]): string[] {
  const additionalLinks: string[] = [];
  const excludeSet = new Set(excludeChannels.filter(Boolean));
  
  for (const url of urls) {
    const cleanUrl = validateAndSanitizeUrl(url);
    if (!cleanUrl || excludeSet.has(cleanUrl)) continue;
    
    // Check if it's a search or discovery URL
    const isSearchUrl = URL_PATTERNS.youtube_search.some(pattern => pattern.test(cleanUrl)) ||
                       URL_PATTERNS.reddit_search.some(pattern => pattern.test(cleanUrl));
    
    if (isSearchUrl || additionalLinks.length < 3) {
      additionalLinks.push(cleanUrl);
    }
  }
  
  return additionalLinks.slice(0, 3); // Limit to 3 additional links
}

/**
 * Processes web search results and extracts structured data
 * @param query - The original search query
 * @param aiGeneratedUrls - URLs generated by AI for the query
 * @returns Structured web search content
 */
export function processWebSearchResults(query: string, aiGeneratedUrls: string[]): WebSearchContent {
  try {
    // Validate input
    if (!Array.isArray(aiGeneratedUrls) || aiGeneratedUrls.length === 0) {
      return {
        youtube_channel_url: null,
        twitch_channel_url: null,
        additional_links: [],
        extraction_metadata: {
          sources_found: 0,
          extraction_successful: false
        }
      };
    }
    
    // Extract channel URLs
    const { youtube, twitch } = extractChannelUrls(aiGeneratedUrls);
    
    // Extract additional links
    const additionalLinks = extractAdditionalLinks(aiGeneratedUrls, [youtube, twitch].filter(Boolean) as string[]);
    
    // Calculate metadata
    const sourcesFound = [youtube, twitch].filter(Boolean).length + additionalLinks.length;
    const extractionSuccessful = sourcesFound > 0;
    
    return {
      youtube_channel_url: youtube,
      twitch_channel_url: twitch,
      additional_links: additionalLinks,
      extraction_metadata: {
        sources_found: sourcesFound,
        extraction_successful: extractionSuccessful
      }
    };
    
  } catch (error) {
    console.error('[URL Extraction] Error processing web search results:', error);
    
    // Return empty structure on error
    return {
      youtube_channel_url: null,
      twitch_channel_url: null,
      additional_links: [],
      extraction_metadata: {
        sources_found: 0,
        extraction_successful: false
      }
    };
  }
}

/**
 * Creates a creator-focused search query for web search
 * @param originalQuery - The original video search query
 * @returns Optimized query for finding creator channels
 */
export function createCreatorSearchQuery(originalQuery: string): string {
  // Extract potential creator name from query
  const creatorMatch = originalQuery.match(/(?:by|from|of)\s+([a-zA-Z0-9_-]+)/i);
  const creatorName = creatorMatch ? creatorMatch[1] : originalQuery.split(' ').pop();
  
  return `${creatorName} channel site:youtube.com OR site:twitch.tv`;
}
